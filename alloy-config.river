// ======= Odkrywanie kontenerów Docker po gnieździe dockera
discovery.docker "compose" {
  host             = "unix:///var/run/docker.sock"
  refresh_interval = "10s"
}

// ======= Relabel: trzymaj tylko usługę z docker-compose o nazwie "app"
discovery.relabel "only_app" {
  targets = discovery.docker.compose.targets

  rule {
    action        = "keep"
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    regex         = "app"
  }
}

// ======= Źródło logów z Dockera (kontenery wyfiltrowane powyżej)
loki.source.docker "app" {
  host             = "unix:///var/run/docker.sock"
  targets    = discovery.relabel.only_app.output
  forward_to = [loki.process.app.receiver]
}

// ======= Przetwarzanie JSON wg Twojego formatu
loki.process "app" {
  stage.json {
    expressions = {
      timestamp      = "timestamp",
      level          = "level",
      message        = "message",
      service        = "service",
      env            = "env",
      version        = "version",
      http_method    = "http_method",
      http_path      = "http_path",
      http_status    = "http_status",
      duration_ms    = "duration_ms",
      trace_id       = "trace_id",
      span_id        = "span_id",
      correlation_id = "correlation_id",
    }
  }

  // Użyj czasu z logu (RFC3339/RFC3339Nano; najlepiej UTC)
  stage.timestamp {
    source = "timestamp"
    format = "RFC3339Nano"
    // timezone = "UTC" // odkomentuj, jeśli w logu brak strefy
  }

  // (opcjonalnie) odrzuć bardzo stare linie
//  stage.drop {
//    older_than          = "90s"
//    drop_counter_reason = "line_too_old"
//  }

  stage.labels {
    values = {
      job     = "docker",
      service = "service",
      env     = "env",
      version = "version",
      level   = "level",
    }
  }

  stage.structured_metadata {
    values = {
      http_method    = "http_method",
      http_path      = "http_path",
      http_status    = "http_status",
      duration_ms    = "duration_ms",
      trace_id       = "trace_id",
      span_id        = "span_id",
      correlation_id = "correlation_id",
    }
  }

  stage.output { source = "message" }

  forward_to = [loki.write.default.receiver]
}

// ======= Wysyłka do Loki
loki.write "default" {
  endpoint { url = "http://loki:3100/loki/api/v1/push" }

  external_labels = {
    cluster = "dev",
  }
}
